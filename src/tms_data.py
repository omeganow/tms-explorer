""" 
TMS Explorer was developed to assist with the data preprocessing of transcranial 
magnetic stimulation (TMS) as part of the study "Transcranial direct current 
stimulation (tDCS) and mindfulness meditation in fibromyalgia" in the "Non-
invasive brain stimulation lab" (NBS) at the university medicine Göttingen (UMG) 
under Prof. Dr. rer. nat. Andrea Antal. PhD student Perianen Ramasawmy conducted 
the study in 2022/2023 and the software was developed based on his requirements.

[DRKS Study Information](https://drks.de/search/de/trial/DRKS00029024)

This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with
this program. If not, see <http://www.gnu.org/licenses/>.

Authors: O. Moschner, T.T. Mai
"""


import os
import pprint
import json

from datetime import datetime
from enum import Enum

import numpy as np
import scipy.io

import matplotlib.pyplot as plt
from matplotlib.figure import Figure

from tms_regression import run_regression, RegressionModels


class TmsPlotObject:
    """Object that holds all the matplotlib objects to plot to an UI target"""

    fig: Figure
    axis: plt.Axes
    linewidth: float = 2.0
    linestyle: str = "solid"
    color: str = "k"

    def __init__(
        self,
        fig: Figure,
        axis: plt.Axes,
        linewidth: float = 2.0,
        linestyle: str = "solid",
        color: str = "k",
    ) -> None:
        self.fig = fig
        self.axis = axis
        self.linewidth = linewidth
        self.linestyle = linestyle
        self.color = color

    def plot(self, x_data, y_data) -> None:
        self.axis.plot(
            x_data,
            y_data,
            linewidth=self.linewidth,
            linestyle=self.linestyle,
            color=self.color,
        )


class TmsFrame:
    """One frame of one measurement with all the information like state, points, etc."""

    values: list[float]
    number: int
    start: float
    state: int
    tag: int
    sweeps: int

    rejected: bool
    inspection_needed: bool = False
    comment: str

    def __init__(
        self,
        values: list[float],
        number: int = 0,
        start: float = 0.0,
        state: int = 0,
        tag: int = 0,
        sweeps: int = 0,
        rejected: bool = False,
        inspection_needed: bool = False,
        comment: str = "",
    ) -> None:
        self.values = values
        self.number = number
        self.start = start
        self.state = state
        self.tag = tag
        self.sweeps = sweeps
        self.rejected = rejected
        self.inspection_needed = inspection_needed
        self.comment = comment

    def get_label(self) -> str:
        return f"{self.number}_{self.rejected}_{self.inspection_needed}"

    def peak_to_peak(self, start_index: int, end_index: int) -> float:
        filtered_range = self.values[start_index:end_index]
        return max(filtered_range) - min(filtered_range)

    def degug_print(self) -> str:
        return f"""
            number : {self.number}
            start : {self.start}
            state : {self.state}
            tag : {self.tag}
            sweeps : {self.sweeps}
            rejected : {self.rejected}
            frames: {self.values[990:1000]}"""


class MeasurementType(Enum):
    AC = "AC"
    BA = "BA"
    LT = "LT"
    PM = "PM"


class TmsMeasurement:
    """Baseclass that holds a list of Frames can be specialized for different measureremnet
    types (S1mv, RECR, etc.)"""

    # Measurement Data
    frames: list[TmsFrame]
    measurement_type: MeasurementType

    # General Information
    tms_name: str
    xunit: str
    start: int
    interval: float
    points: int
    channels: int
    no_frames: int

    # Static Values
    time_values: list[float] = []

    def __init__(self, path: str, measurement_type: MeasurementType) -> None:
        """Loads either a .mat file generated with the Signal Software or an .tms file
        saved from this software"""
        self.measurement_type = measurement_type

        if path.endswith(".mat"):
            self.load_mat_file(path)

    def load_mat_file(self, path: str) -> None:
        """Routine to load a matfile generated by the Signal Software v4.08"""

        # Load Matlab File
        rawdata_matlab_frame = scipy.io.loadmat(path)

        # Extract general Informations
        self.tms_name = list(rawdata_matlab_frame.keys())[-1]  # eg. X000_LT_ICI

        mat_data = rawdata_matlab_frame[self.tms_name]
        self.xunit = mat_data["xunits"].item(0)[0]
        self.start = mat_data["start"].item(0)[0][0]
        self.interval = round(mat_data["interval"].item(0)[0][0], 4)
        self.points = mat_data["points"].item(0)[0][0]
        self.chans = mat_data["chans"].item(0)[0][0]
        self.no_frames = mat_data["frames"].item(0)[0][0]

        # Extract Frameinformations
        frame_infos = []
        for mat_framinfo in mat_data[["frameinfo"]][0][0][0]:
            frame_info = {}
            frame_info["number"] = mat_framinfo["number"]
            frame_info["start"] = mat_framinfo["start"]
            frame_info["state"] = mat_framinfo["state"]
            frame_info["tag"] = mat_framinfo["tag"]
            frame_info["sweeps"] = mat_framinfo["sweeps"]
            frame_infos.append(frame_info)

        # Extract mat_data into Python
        mat_values = mat_data[["values"]]

        self.frames = []
        for framenumber in range(0, self.no_frames):
            framedata = []
            framedata = mat_values[0][0][0].transpose()
            framedata = framedata[framenumber][0]

            self.frames.append(
                TmsFrame(
                    values=framedata,
                    number=frame_infos[framenumber]["number"].item(0)[0][0],
                    start=frame_infos[framenumber]["start"].item(0)[0][0],
                    state=frame_infos[framenumber]["state"].item(0)[0][0],
                    tag=frame_infos[framenumber]["tag"].item(0)[0][0],
                    sweeps=frame_infos[framenumber]["sweeps"].item(0)[0][0],
                )
            )

    def load_tms_file(self, path) -> None:
        """Routine to load an internally generated .tms File"""

        pass

    def get_index_by_time(self, start: float, end: float) -> tuple[int, int]:
        """Windowing calculates the start- and end-index based on the start and
        end time in secods"""
        if end == 0.0:
            end = self.points * self.interval

        return int(start / self.interval), int(end / self.interval)

    def get_time_values(self, start_index: int = 0, end_index: int = 0) -> list[float]:
        """Routine to generate the corresponding time for plotting"""
        if len(self.time_values) == 0:
            self.time_values = np.arange(0, self.points, self.interval).tolist()

        if end_index == 0:
            end_index = self.points
        return self.time_values[start_index:end_index]

    def get_frames_by_state(self, state: int) -> list[TmsFrame]:
        """Selects all the frames with the state"""

        filtered_frames = []
        for frame in self.frames:
            if frame.state == state:
                filtered_frames.append(frame)
        return filtered_frames

    def get_max_min_bound(self) -> tuple[float, float]:
        """Calculate the global maximum and minium value of all frames"""

        max_val = -10000.0  # Default Low
        min_val = 10000.0  # Default High
        for frame in self.frames:
            if max(frame.values) > max_val:
                max_val = max(frame.values)
            if min(frame.values) < min_val:
                min_val = min(frame.values)
        return max_val, min_val

    def run_inspection(self):
        """During 0.07 ≤ t ≤ 0.09, if (max(y)-min(y)) < 0.1 mV, then visually
        inspect (Pulse Control) and the noise level at the beginning of the
        measurement  0.00 ≤ t ≤ 0.07, if (max(y)-min(y)) < 0.05 mV"""

        start_time_pulse_control = 0.07
        end_time_pulse_control = 0.09

        start_pulse_control, end_pulse_control = self.get_index_by_time(
            start_time_pulse_control, end_time_pulse_control
        )

        start_time_noise_control = 0.00
        end_time_noise_control = 0.07
        start_noise_control, end_noise_control = self.get_index_by_time(
            start_time_noise_control, end_time_noise_control
        )

        for frame in self.frames:
            if not frame.rejected:
                if (
                    max(frame.values[start_pulse_control:end_pulse_control])
                    - min(frame.values[start_pulse_control:end_pulse_control])
                ) < 0.1:
                    frame.inspection_needed = True

                if (
                    max(frame.values[start_noise_control:end_noise_control])
                    - min(frame.values[start_noise_control:end_noise_control])
                ) > 0.05:
                    frame.inspection_needed = True

    def get_filtered_frames(
        self, start_frame_sel: int, end_frame_sel: int, state_filter: list[int]
    ) -> list[TmsFrame]:
        """"""
        if end_frame_sel == -1:
            end_frame_sel = len(self.frames)

        if start_frame_sel == end_frame_sel:
            return [self.frames[start_frame_sel]]
        else:
            selected_frames = self.frames[start_frame_sel:end_frame_sel]
            # Frames if filtered by State
            if state_filter:
                filtered_selected_frames = []
                for frame in selected_frames:
                    if frame.state in state_filter and not frame.rejected:
                        filtered_selected_frames.append(frame)
                selected_frames = filtered_selected_frames
            return selected_frames

    def calculate_mean_peak_to_peak(
        self,
        start_index_window: int,
        end_index_window: int,
        start_frame_sel: int = 0,
        end_frame_sel: int = -1,
        state_filter: list[int] = [],
    ) -> float:
        """Calculates the mean peak to peak value of the given frames in the given window"""

        total_mean = 0.0
        number_of_valid_frames = 0
        for frame in self.get_filtered_frames(
            start_frame_sel, end_frame_sel, state_filter
        ):
            if not frame.rejected:
                if len(frame.values[start_index_window:end_index_window]) == 0:
                    print(frame.number)
                else:
                    total_mean = total_mean + frame.peak_to_peak(
                        start_index=start_index_window, end_index=end_index_window
                    )
                    number_of_valid_frames += 1
            else:
                pass
        if number_of_valid_frames == 0:
            return -1
        else:
            total_mean = total_mean / number_of_valid_frames
            return total_mean

    def calculate_mean_graph(
        self,
        start_index_window: int,
        end_index_window: int,
        start_frame_sel: int = 0,
        end_frame_sel: int = -1,
        state_filter: list[int] = [],
    ) -> TmsFrame:
        """Routine to generate a mean graph of the selected frames"""

        total_mean_graph = []
        number_of_valid_frames = 0
        for frame in self.get_filtered_frames(
            start_frame_sel, end_frame_sel, state_filter
        ):
            if not frame.rejected:
                for index in range(start_index_window, end_index_window):
                    if len(total_mean_graph) <= index - start_index_window:
                        total_mean_graph.append(frame.values[index])
                    else:
                        total_mean_graph[index - start_index_window] = (
                            total_mean_graph[index - start_index_window]
                            + frame.values[index]
                        )
                number_of_valid_frames += 1
            else:
                pass

        for index in range(0, len(total_mean_graph)):
            total_mean_graph[index] = total_mean_graph[index] / number_of_valid_frames

        return TmsFrame(
            values=total_mean_graph,
            comment=f"""Mean Graph for {number_of_valid_frames} valid Frames not considering 
            {len(self.frames[start_frame_sel:end_frame_sel])-number_of_valid_frames} 
            invalid frames!""",
        )

    def plot_mean(
        self,
        start_index_window: int,
        end_index_window: int,
        pl: TmsPlotObject,
        start_frame_sel: int = 0,
        end_frame_sel: int = -1,
        state_filter: list[int] = [],
    ) -> None:
        """Plots the mean function of the selected frames"""
        # Function for mean calculation
        pl.plot(
            self.get_time_values(start_index_window, end_index_window),
            self.calculate_mean_graph(
                start_index_window,
                end_index_window,
                start_frame_sel,
                end_frame_sel,
                state_filter,
            ).values,
        )

    def plot_frames(
        self,
        start_index_window: int,
        end_index_window: int,
        pl: TmsPlotObject,
        start_frame_sel: int = 0,
        end_frame_sel: int = -1,
        state_filter: list[int] = [],
        show_rejected: bool = False,
    ) -> None:
        """Plots the selected frames"""
        # Function for mean calculation

        for frame in self.get_filtered_frames(
            start_frame_sel, end_frame_sel, state_filter
        ):
            # Function for plotting the raw data
            if not frame.rejected or show_rejected:
                pl.plot(
                    self.get_time_values(start_index_window, end_index_window),
                    frame.values[start_index_window:end_index_window],
                )

    def get_count_inspection_needed(self) -> int:
        count = 0
        for frame in self.frames:
            if frame.inspection_needed:
                count += 1
        return count

    def get_count_rejected(self) -> int:
        count = 0
        for frame in self.frames:
            if frame.rejected:
                count += 1
        return count

    def plot_external(self, fig: Figure, start_time: float, end_time: float):
        """Virtual Method needs to be implemented in ChildClasses"""
        pass

    def export_data(self) -> dict:
        """Virtual Method needs to be implemented in ChildClasses"""
        pass

    def degug_print(self):
        """Nothing to see here... Move along!"""
        pprint.pprint(
            f"""
            name : {self.tms_name}
            unit : {self.xunit}
            start : {self.start}
            interval : {self.interval}
            points : {self.points}
            chans : {self.chans}
            frames: {self.frames[0].summary()}"""
        )


class Ici(TmsMeasurement):
    """Specialized class for ICI double pulse tms measurements"""

    def __init__(self, path: str, type: MeasurementType) -> None:
        super().__init__(path, type)
        self.run_inspection()

    def plot_external(self, fig: Figure, start_time: float, end_time: float) -> None:
        max_val, min_val = self.get_max_min_bound()

        start_index_window, end_index_window = self.get_index_by_time(
            start_time, end_time
        )

        if end_index_window > self.points:
            fig.suptitle("Data can not be displayed! End_time out of range!")
            return

        # Filter by State
        for state in range(1, 4):
            # Styling Options
            axis = fig.add_subplot(1, 3, state)
            plot_recr_mean = TmsPlotObject(fig, axis, color="r")
            plot_recr_raw = TmsPlotObject(
                fig,
                axis,
                linewidth=1.0,
                linestyle="dotted",
                color="#808080",
            )

            # Plotting
            plot_recr_mean.axis.set_title(f"State: {state}")
            plot_recr_mean.axis.set_ylim(min_val, max_val)

            # Display Mean Curve
            self.plot_mean(
                start_index_window,
                end_index_window,
                pl=plot_recr_mean,
                state_filter=[state],
            )
            # Display Raw Data
            self.plot_frames(
                start_index_window=start_index_window,
                end_index_window=end_index_window,
                pl=plot_recr_raw,
                state_filter=[state],
            )

    def export_data(self, start_time: float, end_time: float) -> dict:
        start_index_window, end_index_window = self.get_index_by_time(
            start_time, end_time
        )
        state1 = self.calculate_mean_peak_to_peak(
            start_index_window, end_index_window, state_filter=[1]
        )
        state2 = self.calculate_mean_peak_to_peak(
            start_index_window, end_index_window, state_filter=[2]
        )
        state3 = self.calculate_mean_peak_to_peak(
            start_index_window, end_index_window, state_filter=[3]
        )

        return {"ici": [round(state1, 4), round(state2, 4), round(state3, 4)]}


class Lici(TmsMeasurement):
    """Specialized class for LICI double pulse measurements"""

    def __init__(self, path: str, type: MeasurementType) -> None:
        super().__init__(path, type)
        self.run_inspection()

    def run_inspection(self):
        pass

    def plot_external(self, fig: Figure, start_time: float, end_time: float) -> None:
        max_val, min_val = self.get_max_min_bound()

        start_index_window, end_index_window = self.get_index_by_time(
            start_time, end_time
        )

        if end_index_window > self.points:
            fig.suptitle("Data can not be displayed! End_time out of range!")
            return

        # Filter by State
        for state in range(1, 4):
            # Styling Options
            axis = fig.add_subplot(1, 4, state)
            plot_recr_mean = TmsPlotObject(fig, axis, color="r")
            plot_recr_raw = TmsPlotObject(
                fig,
                axis,
                linewidth=1.0,
                linestyle="dotted",
                color="#808080",
            )

            # Plotting
            plot_recr_mean.axis.set_title(f"State: {state}")
            plot_recr_mean.axis.set_ylim(min_val, max_val)

            # Display Mean Curve
            self.plot_mean(
                start_index_window,
                end_index_window,
                pl=plot_recr_mean,
                state_filter=[state],
            )
            # Display Raw Data
            self.plot_frames(
                start_index_window=start_index_window,
                end_index_window=end_index_window,
                pl=plot_recr_raw,
                state_filter=[state],
            )
        # Styling Options
        axis = fig.add_subplot(1, 4, 4)
        plot_recr_mean = TmsPlotObject(fig, axis, color="r")
        plot_recr_raw = TmsPlotObject(
            fig,
            axis,
            linewidth=1.0,
            linestyle="dotted",
            color="#808080",
        )

        # Plotting
        plot_recr_mean.axis.set_title(f"Mean State 2 and State 3")
        plot_recr_mean.axis.set_ylim(min_val, max_val)

        # Display Mean Curve
        self.plot_mean(
            start_index_window,
            end_index_window,
            pl=plot_recr_mean,
            state_filter=[2, 3],
        )
        # Display Raw Data
        self.plot_frames(
            start_index_window=start_index_window,
            end_index_window=end_index_window,
            pl=plot_recr_raw,
            state_filter=[2, 3],
        )

    def export_data(self, start_time, end_time) -> dict:
        start_index_window, end_index_window = self.get_index_by_time(
            start_time, end_time
        )
        state1 = self.calculate_mean_peak_to_peak(
            start_index_window, end_index_window, state_filter=[1]
        )
        state2 = self.calculate_mean_peak_to_peak(
            start_index_window, end_index_window, state_filter=[2]
        )
        state3 = self.calculate_mean_peak_to_peak(
            start_index_window, end_index_window, state_filter=[3]
        )
        state2_3 = self.calculate_mean_peak_to_peak(
            start_index_window, end_index_window, state_filter=[2, 3]
        )

        return {
            "lici": [
                round(state1, 4),
                round(state2, 4),
                round(state3, 4),
                round(state2_3, 4),
            ]
        }


class Recr(TmsMeasurement):
    """The data collected for each recruitment curves consists of 60 frames,
    with increasing intensity after each 10 frames as shown below:"""

    regression_overwrite: RegressionModels = None

    def __init__(self, path: str, type: MeasurementType) -> None:
        super().__init__(path, type)
        self.run_inspection()

    def calculate_rmt_values(
        self, start_index_window: int, end_index_window: int
    ) -> tuple[list[int], list[float]]:
        stepping = 10

        rmt_values = []
        peak_peak = []
        for index in range(0, len(self.frames), stepping):
            rmt_values.append(90 + index)
            # If there is an odd measurement count
            if index + stepping > len(self.frames):
                stepping = len(self.frames) - index

            peak_peak.append(
                self.calculate_mean_peak_to_peak(
                    start_index_window == start_index_window,
                    end_index_window=end_index_window,
                    start_frame_sel=index,
                    end_frame_sel=index + stepping,
                )
            )
        return rmt_values, peak_peak

    def calculate_regression_curve(self, x: list[int], y: list[float]):
        """Regression Models are defined in the tms_regression package
        x - RMT(%) and y - MEP(mV) - Multiple Regression Models are available:
        Cubic, Logistic, Gombertz, RevereseGombertz"""

        return run_regression(x, y, self.regression_overwrite)

    def plot_recruitment_means(self, fig: Figure, start_time: float, end_time: float):
        """Plots upto 6 subplots with mean curve and RawData per RMT"""
        max_val, min_val = self.get_max_min_bound()

        start_index_window, end_index_window = self.get_index_by_time(
            start_time, end_time
        )

        stepping = 10
        for index in range(0, len(self.frames), stepping):
            stepping_index = index + stepping
            if stepping_index > len(self.frames):
                stepping_index = index + (len(self.frames) - index)

            # Styling Options
            axis = fig.add_subplot(2, 3, int(index / 10) + 1)
            plot_recr_mean = TmsPlotObject(fig, axis, color="r")
            plot_recr_raw = TmsPlotObject(
                fig,
                axis,
                linewidth=1.0,
                linestyle="dotted",
                color="#808080",
            )

            # Plotting
            plot_recr_mean.axis.set_title(f"Recr RMT(%) {90+index} ")
            plot_recr_mean.axis.set_ylim(min_val, max_val)

            # Display Mean Curve
            self.plot_mean(
                start_index_window,
                end_index_window,
                pl=plot_recr_mean,
                start_frame_sel=index,
                end_frame_sel=index + 10,
            )
            # Display Raw Data
            self.plot_frames(
                start_index_window=start_index_window,
                end_index_window=end_index_window,
                pl=plot_recr_raw,
                start_frame_sel=index,
                end_frame_sel=index + 10,
            )

    def plot_external(self, fig: Figure, start_time: float, end_time: float) -> None:
        """Plots the Recruitment Curve with a regression model"""

        start_index, end_index = self.get_index_by_time(start_time, end_time)

        if end_index > self.points:
            fig.suptitle("Data can not be displayed! End_time out of range!")
            return

        # Plot Styling
        recr_plot = TmsPlotObject(fig, fig.add_subplot(), color="k")

        rmt_values_x, peak_peak_y = self.calculate_rmt_values(start_index, end_index)

        # Recruitment Curve
        recr_plot.axis.set_ylabel("MEP amplitude (mV)", loc="center")
        recr_plot.axis.set_xlabel("Intensity (% of RMT)", loc="center")
        recr_plot.axis.set_ylim(min(peak_peak_y) - 1, max(peak_peak_y) + 1)
        # recr_plot.axis.set_title("Recruitment curve")
        recr_plot.axis.plot(
            rmt_values_x, peak_peak_y, marker="o", color=recr_plot.color
        )

        xx, yy = self.calculate_regression_curve(rmt_values_x, peak_peak_y)
        recr_plot.axis.plot(xx, yy)

        max_value = max(yy)
        half_value = ((max_value - min(yy)) / 2) + min(yy)

        f = np.linspace(half_value, half_value, 100).flatten()
        try:
            idx = np.argwhere(np.diff(np.sign(f - yy)))[0][0]
        except:
            idx = 0

        recr_plot.axis.plot(
            xx,
            np.linspace(max_value, max_value, 100),
            linewidth=1.0,
            linestyle="dotted",
            color="#808080",
            label=f"MEP(140% of RMT) = {round(max_value, 2)}mV",
        )

        recr_plot.axis.plot(
            np.linspace(min(rmt_values_x), xx[idx], 100),
            np.linspace(half_value, half_value, 100),
            linewidth=1.0,
            linestyle="dotted",
            color="r",
        )

        recr_plot.axis.plot(
            np.linspace(xx[idx], xx[idx], 100),
            np.linspace(0, half_value, 100),
            linewidth=1.0,
            linestyle="dotted",
            color="r",
            label=f"S({round(yy.item(idx), 2)}mV) = {round(xx.item(idx), 2)}% of RMT",
        )
        recr_plot.axis.plot(xx[idx], f[idx], "ro")

        def slope(x1, y1, x2, y2):
            return (y2 - y1) / (x2 - x1)

        def cut(x1, y1, x2, y2):
            return (x2 * y1 - x1 * y2) / (x2 - x1)

        m = slope(xx.item(idx), yy.item(idx), xx.item(idx + 1), yy.item(idx + 1))
        b = cut(xx.item(idx), yy.item(idx), xx.item(idx + 1), yy.item(idx + 1))

        recr_plot.axis.plot(xx, m * xx + b, linestyle="dotted", color="g", linewidth=2)
        recr_plot.axis.legend(loc="upper left", shadow=True, fontsize="medium")

    def export_data(self, start_time: float, end_time: float) -> dict:
        start_index, end_index = self.get_index_by_time(start_time, end_time)
        rmt_values_x, peak_peak_y = self.calculate_rmt_values(start_index, end_index)

        xx, yy = self.calculate_regression_curve(rmt_values_x, peak_peak_y)

        max_value = max(yy)
        half_value = ((max_value - min(yy)) / 2) + min(yy)

        f = np.linspace(half_value, half_value, 100).flatten()
        try:
            idx = np.argwhere(np.diff(np.sign(f - yy)))[0][0]
        except:
            idx = 0

        def slope(x1, y1, x2, y2):
            return (y2 - y1) / (x2 - x1)

        def cut(x1, y1, x2, y2):
            return (x2 * y1 - x1 * y2) / (x2 - x1)

        m = slope(xx.item(idx), yy.item(idx), xx.item(idx + 1), yy.item(idx + 1))
        b = cut(xx.item(idx), yy.item(idx), xx.item(idx + 1), yy.item(idx + 1))

        rmt_peak_peak = []
        for index, rmt in enumerate(rmt_values_x):
            rmt_peak_peak.append(round(peak_peak_y[index], 4))

        index += 1
        if index < 6:
            for index in range(index, 6):
                rmt_peak_peak.append(-99999)

        rmt_peak_peak.append(round(yy.item(idx), 2))
        rmt_peak_peak.append(round(m, 3))
        rmt_peak_peak.append(round(xx.item(idx), 2))

        return {"recr": rmt_peak_peak}


class Si1mv(TmsMeasurement):
    """SI1mV is defined as the stimulation intensity to induce an MEP
    peak-to-peak amplitude on an average of 1.0 mV (0.8-1.2 mV)"""

    mv_value: int

    def __init__(self, path: str, type: MeasurementType, mv_value) -> None:
        super().__init__(path, type)
        self.mv_value = mv_value
        for index in range(0, 3):
            self.frames[index].rejected = True
        self.run_inspection()

    def plot_external(self, fig: Figure, start_time: float, end_time: float) -> None:
        """Plots the mean graph and all the valid raw data in the selcted window"""

        start_index_window, end_index_window = self.get_index_by_time(
            start_time, end_time
        )
        if end_index_window > self.points:
            fig.suptitle("Data can not be displayed! End_time out of range!")
            return

        max_val, min_val = self.get_max_min_bound()

        # Styling Options
        axis = fig.add_subplot()
        plot_si1mv_mean = TmsPlotObject(fig, axis, color="r")
        plot_si1mv_raw = TmsPlotObject(
            fig, axis, linewidth=1.0, linestyle="dotted", color="#808080"
        )

        # Plotting
        # plot_si1mv_mean.axis.set_title(f"SI1mv ")
        plot_si1mv_mean.axis.set_ylim(min_val, max_val)

        # Display Mean Curve
        self.plot_mean(
            start_index_window=start_index_window,
            end_index_window=end_index_window,
            pl=plot_si1mv_mean,
        )
        # Display Raw Data
        self.plot_frames(
            start_index_window=start_index_window,
            end_index_window=end_index_window,
            pl=plot_si1mv_raw,
        )

    def export_data(self, start_time: float, end_time: float) -> dict:
        """"""
        start_index_window, end_index_window = self.get_index_by_time(
            start_time, end_time
        )

        return {
            "si1mv": {
                f"mep": round(
                    self.calculate_mean_peak_to_peak(
                        start_index_window, end_index_window
                    ),
                    4,
                ),
                "value": self.mv_value,
            }
        }


class TmsPatient:
    subject_name: str
    path: str

    measurement_data: dict[str, dict[str, TmsMeasurement]]
    import_report: list
    preferences: dict

    start_time_si1mv: float = 0.10
    end_time_si1mv: float = 0.13

    start_time_recr: float = 0.10
    end_time_recr: float = 0.13

    start_time_ici: float = 0.10
    end_time_ici: float = 0.13

    start_time_lici: float = 0.26
    end_time_lici: float = 0.30

    def __init__(self, subject_name: str, path: str) -> None:
        self.path = path
        self.subject_name = subject_name
        self.init_data_struct()
        self.load_patient_files()

    def init_data_struct(self):
        self.import_report = []
        self.measurement_data = {}
        for session in ["ba", "pm", "ac", "lt"]:
            self.measurement_data[session] = {}

    def parse_mat_file(self, file):
        valid_file = True
        file_with_no_ending = file.replace(".mat", "")
        name_components = file_with_no_ending.split("_")

        name_file = name_components[0]
        type_file = name_components[1]
        tms_file = name_components[2].lower()

        if name_file != self.subject_name:
            valid_file = False
            self.import_report.append(f"{datetime.now()}-ERROR:::: Wrong Patient Name")

        type = None
        if type_file == "BA":
            type = MeasurementType.BA
        elif type_file == "PM":
            type = MeasurementType.PM
        elif type_file == "AC":
            type = MeasurementType.AC
        elif type_file == "LT":
            type = MeasurementType.LT
        else:
            valid_file = False
            self.import_report.append(f"{datetime.now()}-ERROR:::: Wrong Type")

        if tms_file == "ici" and valid_file:
            self.measurement_data[type.name.lower()][tms_file] = Ici(
                f"{self.path}/{self.subject_name}/{file}", type
            )
            self.import_report.append(
                f"{datetime.now()}-INFO:::: {file} loaded successfully!"
            )
        elif tms_file == "lici" and valid_file:
            self.measurement_data[type.name.lower()][tms_file] = Lici(
                f"{self.path}/{self.subject_name}/{file}", type
            )
            self.import_report.append(
                f"{datetime.now()}-INFO:::: {file} loaded successfully!"
            )
        elif tms_file == "recr" and valid_file:
            self.measurement_data[type.name.lower()][tms_file] = Recr(
                f"{self.path}/{self.subject_name}/{file}", type
            )
            self.import_report.append(
                f"{datetime.now()}-INFO:::: {file} loaded successfully!"
            )
        elif tms_file == "si1mv" and valid_file:
            if len(name_components) > 3:
                try:
                    mv_value = int(name_components[3])
                    self.measurement_data[type.name.lower()][tms_file] = Si1mv(
                        f"{self.path}/{self.subject_name}/{file}",
                        type,
                        mv_value,
                    )
                    self.import_report.append(
                        f"{datetime.now()}-INFO:::: {file} loaded successfully!"
                    )
                except:
                    self.import_report.append(
                        f"{datetime.now()}-ERROR:::: {file} mV value could not be converted!"
                    )

            else:
                self.import_report.append(
                    f"{datetime.now()}-ERROR:::: {file} mV value could not be extracted!"
                )

        else:
            self.import_report.append(
                f"{datetime.now()}-ERROR:::: {file} could not be loaded!"
            )

    def load_preferences(self):
        preferences_filename = f"{self.path}/{self.subject_name}/.rejected.tms"
        if not os.path.isfile(preferences_filename):
            self.save_preferences()

        self.preferences = {}
        with open(preferences_filename) as pref:
            self.preferences = json.load(pref)

        for session in self.preferences:
            for type in self.preferences[session]:
                for index, rejected in enumerate(self.preferences[session][type]):
                    self.measurement_data[session][type].frames[
                        index
                    ].rejected = rejected

    def load_overwrites(self):
        overwrites_filename = f"{self.path}/{self.subject_name}/.overwrites.tms"
        if not os.path.isfile(overwrites_filename):
            self.save_overwrites()

        self.regression_overwrites = {}
        with open(overwrites_filename) as overwrites:
            self.regression_overwrites = json.load(overwrites)

        for session in self.regression_overwrites:
            if self.regression_overwrites[session] != "Default":
                if "recr" in self.measurement_data[session].keys():
                    for model in RegressionModels:
                        if model.name == self.regression_overwrites[session]:
                            self.measurement_data[session][
                                "recr"
                            ].regression_overwrite = model

    def save_preferences(self):
        self.preferences = {}
        for session in self.measurement_data:
            self.preferences[session] = {}
            for type in self.measurement_data[session]:
                self.preferences[session][type] = []
                for frame in self.measurement_data[session][type].frames:
                    self.preferences[session][type].append(frame.rejected)

        preferences_filename = f"{self.path}/{self.subject_name}/.rejected.tms"
        with open(preferences_filename, "w") as pref:
            json.dump(self.preferences, pref)

    def save_overwrites(self):
        self.regression_overwrites = {}
        for session in self.measurement_data:
            if "recr" in self.measurement_data[session].keys():
                overwrite = "Default"
                if (
                    self.measurement_data[session]["recr"].regression_overwrite
                    is not None
                ):
                    overwrite = self.measurement_data[session][
                        "recr"
                    ].regression_overwrite.name
                self.regression_overwrites[session] = overwrite

        overwrites_filename = f"{self.path}/{self.subject_name}/.overwrites.tms"
        with open(overwrites_filename, "w") as overwrites:
            json.dump(self.regression_overwrites, overwrites)

    def load_patient_files(self):
        self.import_report.append(
            f"{datetime.now()}-INFO:::: Importing Patient {self.subject_name}"
        )
        for file in os.listdir(f"{self.path}/{self.subject_name}"):
            if file.endswith(".mat"):
                self.parse_mat_file(file)

        self.load_preferences()
        self.load_overwrites()

    def export_data(self) -> dict:
        export: dict = {}

        for session in ["ba", "pm", "ac", "lt"]:
            if len(self.measurement_data.get(session)) != 0:
                export[session] = {}
                if self.measurement_data[session].get("si1mv") is not None:
                    export[session].update(
                        self.measurement_data[session]["si1mv"].export_data(
                            self.start_time_si1mv, self.end_time_si1mv
                        )
                    )

                if self.measurement_data[session].get("recr") is not None:
                    export[session].update(
                        self.measurement_data[session]["recr"].export_data(
                            self.start_time_recr, self.end_time_recr
                        )
                    )

                if self.measurement_data[session].get("ici") is not None:
                    export[session].update(
                        self.measurement_data[session]["ici"].export_data(
                            self.start_time_ici, self.end_time_ici
                        )
                    )

                if self.measurement_data[session].get("lici") is not None:
                    export[session].update(
                        self.measurement_data[session]["lici"].export_data(
                            self.start_time_lici, self.end_time_lici
                        )
                    )

        return {self.subject_name: export}

    def filtered_measurements(
        self,
        session_types: list[str],
        tms_types: list[str],
        only_inspection_needed: bool = False,
        show_rejected: bool = True,
    ) -> list[TmsFrame]:
        """"""

        filtered_frames = []
        for session_type in session_types:
            for tms_type in tms_types:
                for frame in self.measurement_data[session_type][tms_type].frames:
                    if only_inspection_needed:
                        if frame.inspection_needed:
                            filtered_frames.append(frame)
                        else:
                            if show_rejected:
                                filtered_frames.append(frame)
                            else:
                                if not frame.rejected:
                                    filtered_frames.append(frame)

        return filtered_frames

    def get_count_inspection_needed(self, key: str):
        count = 0
        if self.measurement_data.get(key) is not None:
            for mes_type in self.measurement_data[key]:
                count += self.measurement_data[key][
                    mes_type
                ].get_count_inspection_needed()
            return count
        return -1

    def get_count_rejected(self, key: str):
        count = 0
        if self.measurement_data.get(key) is not None:
            for mes_type in self.measurement_data[key]:
                count += self.measurement_data[key][mes_type].get_count_rejected()
            return count
        return -1

    def plot(self, session: str, type: str, fig: Figure):
        current_mes: TmsMeasurement = self.measurement_data[session][type]
        if isinstance(current_mes, Si1mv):
            current_mes.plot_external(fig, self.start_time_si1mv, self.end_time_si1mv)
        elif isinstance(current_mes, Recr):
            current_mes.plot_external(fig, self.start_time_recr, self.end_time_recr)
        elif isinstance(current_mes, Ici):
            current_mes.plot_external(fig, self.start_time_ici, self.end_time_ici)
        elif isinstance(current_mes, Lici):
            current_mes.plot_external(fig, self.start_time_lici, self.end_time_lici)
