import os
import pprint
import json

from datetime import datetime
from enum import Enum

import numpy as np
import scipy.io

import matplotlib.pyplot as plt
from matplotlib.figure import Figure

from tms_regression import run_regression, RegressionModels


class TmsPlotObject:
    """Object that holds all the matplotlib objects to plot to an UI target"""

    fig: Figure
    axis: plt.Axes
    linewidth: float = 2.0
    linestyle: str = "solid"
    color: str = "k"

    def __init__(
        self,
        fig: Figure,
        axis: plt.Axes,
        linewidth: float = 2.0,
        linestyle: str = "solid",
        color: str = "k",
    ) -> None:
        self.fig = fig
        self.axis = axis
        self.linewidth = linewidth
        self.linestyle = linestyle
        self.color = color

    def plot(self, x_data, y_data) -> None:
        self.axis.plot(
            x_data,
            y_data,
            linewidth=self.linewidth,
            linestyle=self.linestyle,
            color=self.color,
        )


class TmsFrame:
    """One frame of one measurement with all the information like state, points, etc."""

    values: list[float]
    number: int
    start: float
    state: int
    tag: int
    sweeps: int

    rejected: bool
    inspection_needed: bool = False
    comment: str

    def __init__(
        self,
        values: list[float],
        number: int = 0,
        start: float = 0.0,
        state: int = 0,
        tag: int = 0,
        sweeps: int = 0,
        rejected: bool = False,
        inspection_needed: bool = False,
        comment: str = "",
    ) -> None:
        self.values = values
        self.number = number
        self.start = start
        self.state = state
        self.tag = tag
        self.sweeps = sweeps
        self.rejected = rejected
        self.inspection_needed = inspection_needed
        self.comment = comment

    def get_label(self) -> str:
        return f"{self.number}_{self.rejected}_{self.inspection_needed}"

    def peak_to_peak(self, start_index: int, end_index: int) -> float:
        filtered_range = self.values[start_index:end_index]
        return max(filtered_range) - min(filtered_range)

    def degug_print(self) -> str:
        return f"""
            number : {self.number}
            start : {self.start}
            state : {self.state}
            tag : {self.tag}
            sweeps : {self.sweeps}
            rejected : {self.rejected}
            frames: {self.values[990:1000]}"""


class MeasurementType(Enum):
    AC = "AC"
    BA = "BA"
    LT = "LT"
    PM = "PM"


class TmsMeasurement:
    """Baseclass that holds a list of Frames can be specialized for different measureremnet
    types (S1mv, RECR, etc.)"""

    # Measurement Data
    frames: list[TmsFrame]
    measurement_type: MeasurementType

    # General Information
    tms_name: str
    xunit: str
    start: int
    interval: float
    points: int
    channels: int
    no_frames: int

    # Static Values
    time_values: list[float] = []

    def __init__(self, path: str, measurement_type: MeasurementType) -> None:
        """Loads either a .mat file generated with the Signal Software or an .tms file
        saved from this software"""
        self.measurement_type = measurement_type

        if path.endswith(".mat"):
            self.load_mat_file(path)

    def load_mat_file(self, path: str) -> None:
        """Routine to load a matfile generated by the Signal Software v4.08"""

        # Load Matlab File
        rawdata_matlab_frame = scipy.io.loadmat(path)

        # Extract general Informations
        self.tms_name = list(rawdata_matlab_frame.keys())[-1]  # eg. X000_LT_ICI

        mat_data = rawdata_matlab_frame[self.tms_name]
        self.xunit = mat_data["xunits"].item(0)[0]
        self.start = mat_data["start"].item(0)[0][0]
        self.interval = round(mat_data["interval"].item(0)[0][0], 4)
        self.points = mat_data["points"].item(0)[0][0]
        self.chans = mat_data["chans"].item(0)[0][0]
        self.no_frames = mat_data["frames"].item(0)[0][0]

        # Extract Frameinformations
        frame_infos = []
        for mat_framinfo in mat_data[["frameinfo"]][0][0][0]:
            frame_info = {}
            frame_info["number"] = mat_framinfo["number"]
            frame_info["start"] = mat_framinfo["start"]
            frame_info["state"] = mat_framinfo["state"]
            frame_info["tag"] = mat_framinfo["tag"]
            frame_info["sweeps"] = mat_framinfo["sweeps"]
            frame_infos.append(frame_info)

        # Extract mat_data into Python
        mat_values = mat_data[["values"]]

        self.frames = []
        for framenumber in range(0, self.no_frames):
            framedata = []
            framedata = mat_values[0][0][0].transpose()
            framedata = framedata[framenumber][0]

            self.frames.append(
                TmsFrame(
                    values=framedata,
                    number=frame_infos[framenumber]["number"].item(0)[0][0],
                    start=frame_infos[framenumber]["start"].item(0)[0][0],
                    state=frame_infos[framenumber]["state"].item(0)[0][0],
                    tag=frame_infos[framenumber]["tag"].item(0)[0][0],
                    sweeps=frame_infos[framenumber]["sweeps"].item(0)[0][0],
                )
            )

    def load_tms_file(self, path) -> None:
        """Routine to load an internally generated .tms File"""

        pass

    def get_index_by_time(self, start: float, end: float) -> tuple[int, int]:
        """Windowing calculates the start- and end-index based on the start and
        end time in secods"""
        if end == 0.0:
            end = self.points * self.interval

        return int(start / self.interval), int(end / self.interval)

    def get_time_values(self, start_index: int = 0, end_index: int = 0) -> list[float]:
        """Routine to generate the corresponding time for plotting"""
        if len(self.time_values) == 0:
            self.time_values = np.arange(0, self.points, self.interval).tolist()

        if end_index == 0:
            end_index = self.points
        return self.time_values[start_index:end_index]

    def get_frames_by_state(self, state: int) -> list[TmsFrame]:
        """Selects all the frames with the state"""

        filtered_frames = []
        for frame in self.frames:
            if frame.state == state:
                filtered_frames.append(frame)
        return filtered_frames

    def get_max_min_bound(self) -> tuple[float, float]:
        """Calculate the global maximum and minium value of all frames"""

        max_val = -10000.0  # Default Low
        min_val = 10000.0  # Default High
        for frame in self.frames:
            if max(frame.values) > max_val:
                max_val = max(frame.values)
            if min(frame.values) < min_val:
                min_val = min(frame.values)
        return max_val, min_val

    def run_inspection(self):
        """During 0.07 ≤ t ≤ 0.09, if (max(y)-min(y)) < 0.1 mV, then visually
        inspect (Pulse Control) and the noise level at the beginning of the
        measurement  0.00 ≤ t ≤ 0.07, if (max(y)-min(y)) < 0.05 mV"""

        start_time_pulse_control = 0.07
        end_time_pulse_control = 0.09

        start_pulse_control, end_pulse_control = self.get_index_by_time(
            start_time_pulse_control, end_time_pulse_control
        )

        start_time_noise_control = 0.00
        end_time_noise_control = 0.07
        start_noise_control, end_noise_control = self.get_index_by_time(
            start_time_noise_control, end_time_noise_control
        )

        for frame in self.frames:
            if not frame.rejected:
                if (
                    max(frame.values[start_pulse_control:end_pulse_control])
                    - min(frame.values[start_pulse_control:end_pulse_control])
                ) < 0.1:
                    frame.inspection_needed = True

                if (
                    max(frame.values[start_noise_control:end_noise_control])
                    - min(frame.values[start_noise_control:end_noise_control])
                ) > 0.05:
                    frame.inspection_needed = True

    def get_filtered_frames(
        self, start_frame_sel: int, end_frame_sel: int, state_filter: list[int]
    ) -> list[TmsFrame]:
        """"""
        if end_frame_sel == -1:
            end_frame_sel = len(self.frames)

        if start_frame_sel == end_frame_sel:
            return [self.frames[start_frame_sel]]
        else:
            selected_frames = self.frames[start_frame_sel:end_frame_sel]
            # Frames if filtered by State
            if state_filter:
                filtered_selected_frames = []
                for frame in selected_frames:
                    if frame.state in state_filter and not frame.rejected:
                        filtered_selected_frames.append(frame)
                selected_frames = filtered_selected_frames
            return selected_frames

    def calculate_mean_peak_to_peak(
        self,
        start_index_window: int,
        end_index_window: int,
        start_frame_sel: int = 0,
        end_frame_sel: int = -1,
        state_filter: list[int] = [],
    ) -> float:
        """Calculates the mean peak to peak value of the given frames in the given window"""

        total_mean = 0.0
        number_of_valid_frames = 0
        for frame in self.get_filtered_frames(
            start_frame_sel, end_frame_sel, state_filter
        ):
            if not frame.rejected:
                if len(frame.values[start_index_window:end_index_window]) == 0:
                    print(frame.number)
                else:
                    total_mean = total_mean + frame.peak_to_peak(
                        start_index=start_index_window, end_index=end_index_window
                    )
                    number_of_valid_frames += 1
            else:
                pass
        if number_of_valid_frames == 0:
            return -1
        else:
            total_mean = total_mean / number_of_valid_frames
            return total_mean

    def calculate_mean_graph(
        self,
        start_index_window: int,
        end_index_window: int,
        start_frame_sel: int = 0,
        end_frame_sel: int = -1,
        state_filter: list[int] = [],
    ) -> TmsFrame:
        """Routine to generate a mean graph of the selected frames"""

        total_mean_graph = []
        number_of_valid_frames = 0
        for frame in self.get_filtered_frames(
            start_frame_sel, end_frame_sel, state_filter
        ):
            if not frame.rejected:
                for index in range(start_index_window, end_index_window):
                    if len(total_mean_graph) <= index - start_index_window:
                        total_mean_graph.append(frame.values[index])
                    else:
                        total_mean_graph[index - start_index_window] = (
                            total_mean_graph[index - start_index_window]
                            + frame.values[index]
                        )
                number_of_valid_frames += 1
            else:
                pass

        for index in range(0, len(total_mean_graph)):
            total_mean_graph[index] = total_mean_graph[index] / number_of_valid_frames

        return TmsFrame(
            values=total_mean_graph,
            comment=f"""Mean Graph for {number_of_valid_frames} valid Frames not considering 
            {len(self.frames[start_frame_sel:end_frame_sel])-number_of_valid_frames} 
            invalid frames!""",
        )

    def plot_mean(
        self,
        start_index_window: int,
        end_index_window: int,
        pl: TmsPlotObject,
        start_frame_sel: int = 0,
        end_frame_sel: int = -1,
        state_filter: list[int] = [],
    ) -> None:
        """Plots the mean function of the selected frames"""
        # Function for mean calculation
        pl.plot(
            self.get_time_values(start_index_window, end_index_window),
            self.calculate_mean_graph(
                start_index_window,
                end_index_window,
                start_frame_sel,
                end_frame_sel,
                state_filter,
            ).values,
        )

    def plot_frames(
        self,
        start_index_window: int,
        end_index_window: int,
        pl: TmsPlotObject,
        start_frame_sel: int = 0,
        end_frame_sel: int = -1,
        state_filter: list[int] = [],
        show_rejected: bool = False,
    ) -> None:
        """Plots the selected frames"""
        # Function for mean calculation

        for frame in self.get_filtered_frames(
            start_frame_sel, end_frame_sel, state_filter
        ):
            # Function for plotting the raw data
            if not frame.rejected or show_rejected:
                pl.plot(
                    self.get_time_values(start_index_window, end_index_window),
                    frame.values[start_index_window:end_index_window],
                )

    def get_count_inspection_needed(self) -> int:
        count = 0
        for frame in self.frames:
            if frame.inspection_needed:
                count += 1
        return count

    def get_count_rejected(self) -> int:
        count = 0
        for frame in self.frames:
            if frame.rejected:
                count += 1
        return count

    def plot_external(self, fig: Figure, start_time: float, end_time: float):
        """Virtual Method needs to be implemented in ChildClasses"""
        pass

    def export_data(self) -> dict:
        """Virtual Method needs to be implemented in ChildClasses"""
        pass

    def degug_print(self):
        """Nothing to see here... Move along!"""
        pprint.pprint(
            f"""
            name : {self.tms_name}
            unit : {self.xunit}
            start : {self.start}
            interval : {self.interval}
            points : {self.points}
            chans : {self.chans}
            frames: {self.frames[0].summary()}"""
        )


class Ici(TmsMeasurement):
    """Specialized class for ICI double pulse tms measurements"""

    def __init__(self, path: str, type: MeasurementType) -> None:
        super().__init__(path, type)
        self.run_inspection()

    def plot_external(self, fig: Figure, start_time: float, end_time: float) -> None:
        max_val, min_val = self.get_max_min_bound()

        start_index_window, end_index_window = self.get_index_by_time(
            start_time, end_time
        )

        if end_index_window > self.points:
            fig.suptitle("Data can not be displayed! End_time out of range!")
            return

        # Filter by State
        for state in range(1, 4):
            # Styling Options
            axis = fig.add_subplot(1, 3, state)
            plot_recr_mean = TmsPlotObject(fig, axis, color="r")
            plot_recr_raw = TmsPlotObject(
                fig,
                axis,
                linewidth=1.0,
                linestyle="dotted",
                color="#808080",
            )

            # Plotting
            plot_recr_mean.axis.set_title(f"State: {state}")
            plot_recr_mean.axis.set_ylim(min_val, max_val)

            # Display Mean Curve
            self.plot_mean(
                start_index_window,
                end_index_window,
                pl=plot_recr_mean,
                state_filter=[state],
            )
            # Display Raw Data
            self.plot_frames(
                start_index_window=start_index_window,
                end_index_window=end_index_window,
                pl=plot_recr_raw,
                state_filter=[state],
            )

    def export_data(self, start_time: float, end_time: float) -> dict:
        start_index_window, end_index_window = self.get_index_by_time(
            start_time, end_time
        )
        state1 = self.calculate_mean_peak_to_peak(
            start_index_window, end_index_window, state_filter=[1]
        )
        state2 = self.calculate_mean_peak_to_peak(
            start_index_window, end_index_window, state_filter=[2]
        )
        state3 = self.calculate_mean_peak_to_peak(
            start_index_window, end_index_window, state_filter=[3]
        )

        return {"ici": [round(state1, 4), round(state2, 4), round(state3, 4)]}


class Lici(TmsMeasurement):
    """Specialized class for LICI double pulse measurements"""

    def __init__(self, path: str, type: MeasurementType) -> None:
        super().__init__(path, type)
        self.run_inspection()

    def run_inspection(self):
        pass

    def plot_external(self, fig: Figure, start_time: float, end_time: float) -> None:
        max_val, min_val = self.get_max_min_bound()

        start_index_window, end_index_window = self.get_index_by_time(
            start_time, end_time
        )

        if end_index_window > self.points:
            fig.suptitle("Data can not be displayed! End_time out of range!")
            return

        # Filter by State
        for state in range(1, 4):
            # Styling Options
            axis = fig.add_subplot(1, 4, state)
            plot_recr_mean = TmsPlotObject(fig, axis, color="r")
            plot_recr_raw = TmsPlotObject(
                fig,
                axis,
                linewidth=1.0,
                linestyle="dotted",
                color="#808080",
            )

            # Plotting
            plot_recr_mean.axis.set_title(f"State: {state}")
            plot_recr_mean.axis.set_ylim(min_val, max_val)

            # Display Mean Curve
            self.plot_mean(
                start_index_window,
                end_index_window,
                pl=plot_recr_mean,
                state_filter=[state],
            )
            # Display Raw Data
            self.plot_frames(
                start_index_window=start_index_window,
                end_index_window=end_index_window,
                pl=plot_recr_raw,
                state_filter=[state],
            )
        # Styling Options
        axis = fig.add_subplot(1, 4, 4)
        plot_recr_mean = TmsPlotObject(fig, axis, color="r")
        plot_recr_raw = TmsPlotObject(
            fig,
            axis,
            linewidth=1.0,
            linestyle="dotted",
            color="#808080",
        )

        # Plotting
        plot_recr_mean.axis.set_title(f"Mean State 2 and State 3")
        plot_recr_mean.axis.set_ylim(min_val, max_val)

        # Display Mean Curve
        self.plot_mean(
            start_index_window,
            end_index_window,
            pl=plot_recr_mean,
            state_filter=[2, 3],
        )
        # Display Raw Data
        self.plot_frames(
            start_index_window=start_index_window,
            end_index_window=end_index_window,
            pl=plot_recr_raw,
            state_filter=[2, 3],
        )

    def export_data(self, start_time, end_time) -> dict:
        start_index_window, end_index_window = self.get_index_by_time(
            start_time, end_time
        )
        state1 = self.calculate_mean_peak_to_peak(
            start_index_window, end_index_window, state_filter=[1]
        )
        state2 = self.calculate_mean_peak_to_peak(
            start_index_window, end_index_window, state_filter=[2]
        )
        state3 = self.calculate_mean_peak_to_peak(
            start_index_window, end_index_window, state_filter=[3]
        )
        state2_3 = self.calculate_mean_peak_to_peak(
            start_index_window, end_index_window, state_filter=[2, 3]
        )

        return {
            "lici": [
                round(state1, 4),
                round(state2, 4),
                round(state3, 4),
                round(state2_3, 4),
            ]
        }


class Recr(TmsMeasurement):
    """The data collected for each recruitment curves consists of 60 frames,
    with increasing intensity after each 10 frames as shown below:"""

    regression_overwrite: RegressionModels = None

    def __init__(self, path: str, type: MeasurementType) -> None:
        super().__init__(path, type)
        self.run_inspection()

    def calculate_rmt_values(
        self, start_index_window: int, end_index_window: int
    ) -> tuple[list[int], list[float]]:
        stepping = 10

        rmt_values = []
        peak_peak = []
        for index in range(0, len(self.frames), stepping):
            rmt_values.append(90 + index)
            # If there is an odd measurement count
            if index + stepping > len(self.frames):
                stepping = len(self.frames) - index

            peak_peak.append(
                self.calculate_mean_peak_to_peak(
                    start_index_window == start_index_window,
                    end_index_window=end_index_window,
                    start_frame_sel=index,
                    end_frame_sel=index + stepping,
                )
            )
        return rmt_values, peak_peak

    def calculate_regression_curve(self, x: list[int], y: list[float]):
        """Regression Models are defined in the tms_regression package
        x - RMT(%) and y - MEP(mV) - Multiple Regression Models are available:
        Cubic, Logistic, Gombertz, RevereseGombertz"""

        return run_regression(x, y, self.regression_overwrite)

    def plot_recruitment_means(self, fig: Figure, start_time: float, end_time: float):
        """Plots upto 6 subplots with mean curve and RawData per RMT"""
        max_val, min_val = self.get_max_min_bound()

        start_index_window, end_index_window = self.get_index_by_time(
            start_time, end_time
        )

        stepping = 10
        for index in range(0, len(self.frames), stepping):
            stepping_index = index + stepping
            if stepping_index > len(self.frames):
                stepping_index = index + (len(self.frames) - index)

            # Styling Options
            axis = fig.add_subplot(2, 3, int(index / 10) + 1)
            plot_recr_mean = TmsPlotObject(fig, axis, color="r")
            plot_recr_raw = TmsPlotObject(
                fig,
                axis,
                linewidth=1.0,
                linestyle="dotted",
                color="#808080",
            )

            # Plotting
            plot_recr_mean.axis.set_title(f"Recr RMT(%) {90+index} ")
            plot_recr_mean.axis.set_ylim(min_val, max_val)

            # Display Mean Curve
            self.plot_mean(
                start_index_window,
                end_index_window,
                pl=plot_recr_mean,
                start_frame_sel=index,
                end_frame_sel=index + 10,
            )
            # Display Raw Data
            self.plot_frames(
                start_index_window=start_index_window,
                end_index_window=end_index_window,
                pl=plot_recr_raw,
                start_frame_sel=index,
                end_frame_sel=index + 10,
            )

    def plot_external(self, fig: Figure, start_time: float, end_time: float) -> None:
        """Plots the Recruitment Curve with a regression model"""

        start_index, end_index = self.get_index_by_time(start_time, end_time)

        if end_index > self.points:
            fig.suptitle("Data can not be displayed! End_time out of range!")
            return

        # Plot Styling
        recr_plot = TmsPlotObject(fig, fig.add_subplot(), color="k")

        rmt_values_x, peak_peak_y = self.calculate_rmt_values(start_index, end_index)

        # Recruitment Curve
        recr_plot.axis.set_ylabel("MEP amplitude (mV)", loc="center")
        recr_plot.axis.set_xlabel("Intensity (% of RMT)", loc="center")
        recr_plot.axis.set_ylim(min(peak_peak_y) - 1, max(peak_peak_y) + 1)
        # recr_plot.axis.set_title("Recruitment curve")
        recr_plot.axis.plot(
            rmt_values_x, peak_peak_y, marker="o", color=recr_plot.color
        )

        xx, yy = self.calculate_regression_curve(rmt_values_x, peak_peak_y)
        recr_plot.axis.plot(xx, yy)

        max_value = max(yy)
        half_value = ((max_value - min(yy)) / 2) + min(yy)

        f = np.linspace(half_value, half_value, 100).flatten()
        try:
            idx = np.argwhere(np.diff(np.sign(f - yy)))[0][0]
        except:
            idx = 0

        recr_plot.axis.plot(
            xx,
            np.linspace(max_value, max_value, 100),
            linewidth=1.0,
            linestyle="dotted",
            color="#808080",
            label=f"MEP(140% of RMT) = {round(max_value, 2)}mV",
        )

        recr_plot.axis.plot(
            np.linspace(min(rmt_values_x), xx[idx], 100),
            np.linspace(half_value, half_value, 100),
            linewidth=1.0,
            linestyle="dotted",
            color="r",
        )

        recr_plot.axis.plot(
            np.linspace(xx[idx], xx[idx], 100),
            np.linspace(0, half_value, 100),
            linewidth=1.0,
            linestyle="dotted",
            color="r",
            label=f"S({round(yy.item(idx), 2)}mV) = {round(xx.item(idx), 2)}% of RMT",
        )
        recr_plot.axis.plot(xx[idx], f[idx], "ro")

        def slope(x1, y1, x2, y2):
            return (y2 - y1) / (x2 - x1)

        def cut(x1, y1, x2, y2):
            return (x2 * y1 - x1 * y2) / (x2 - x1)

        m = slope(xx.item(idx), yy.item(idx), xx.item(idx + 1), yy.item(idx + 1))
        b = cut(xx.item(idx), yy.item(idx), xx.item(idx + 1), yy.item(idx + 1))

        recr_plot.axis.plot(xx, m * xx + b, linestyle="dotted", color="g", linewidth=2)
        recr_plot.axis.legend(loc="upper left", shadow=True, fontsize="medium")

    def export_data(self, start_time: float, end_time: float) -> dict:
        start_index, end_index = self.get_index_by_time(start_time, end_time)
        rmt_values_x, peak_peak_y = self.calculate_rmt_values(start_index, end_index)

        xx, yy = self.calculate_regression_curve(rmt_values_x, peak_peak_y)

        max_value = max(yy)
        half_value = ((max_value - min(yy)) / 2) + min(yy)

        f = np.linspace(half_value, half_value, 100).flatten()
        try:
            idx = np.argwhere(np.diff(np.sign(f - yy)))[0][0]
        except:
            idx = 0

        def slope(x1, y1, x2, y2):
            return (y2 - y1) / (x2 - x1)

        def cut(x1, y1, x2, y2):
            return (x2 * y1 - x1 * y2) / (x2 - x1)

        m = slope(xx.item(idx), yy.item(idx), xx.item(idx + 1), yy.item(idx + 1))
        b = cut(xx.item(idx), yy.item(idx), xx.item(idx + 1), yy.item(idx + 1))

        rmt_peak_peak = []
        for index, rmt in enumerate(rmt_values_x):
            rmt_peak_peak.append(round(peak_peak_y[index], 4))

        index += 1
        if index < 6:
            for index in range(index, 6):
                rmt_peak_peak.append(-99999)

        rmt_peak_peak.append(round(yy.item(idx), 2))
        rmt_peak_peak.append(round(m, 3))
        rmt_peak_peak.append(round(xx.item(idx), 2))

        return {"recr": rmt_peak_peak}


class Si1mv(TmsMeasurement):
    """SI1mV is defined as the stimulation intensity to induce an MEP
    peak-to-peak amplitude on an average of 1.0 mV (0.8-1.2 mV)"""

    mv_value: int

    def __init__(self, path: str, type: MeasurementType, mv_value) -> None:
        super().__init__(path, type)
        self.mv_value = mv_value
        for index in range(0, 3):
            self.frames[index].rejected = True
        self.run_inspection()

    def plot_external(self, fig: Figure, start_time: float, end_time: float) -> None:
        """Plots the mean graph and all the valid raw data in the selcted window"""

        start_index_window, end_index_window = self.get_index_by_time(
            start_time, end_time
        )
        if end_index_window > self.points:
            fig.suptitle("Data can not be displayed! End_time out of range!")
            return

        max_val, min_val = self.get_max_min_bound()

        # Styling Options
        axis = fig.add_subplot()
        plot_si1mv_mean = TmsPlotObject(fig, axis, color="r")
        plot_si1mv_raw = TmsPlotObject(
            fig, axis, linewidth=1.0, linestyle="dotted", color="#808080"
        )

        # Plotting
        # plot_si1mv_mean.axis.set_title(f"SI1mv ")
        plot_si1mv_mean.axis.set_ylim(min_val, max_val)

        # Display Mean Curve
        self.plot_mean(
            start_index_window=start_index_window,
            end_index_window=end_index_window,
            pl=plot_si1mv_mean,
        )
        # Display Raw Data
        self.plot_frames(
            start_index_window=start_index_window,
            end_index_window=end_index_window,
            pl=plot_si1mv_raw,
        )

    def export_data(self, start_time: float, end_time: float) -> dict:
        """"""
        start_index_window, end_index_window = self.get_index_by_time(
            start_time, end_time
        )

        return {
            "si1mv": {
                f"mep": round(
                    self.calculate_mean_peak_to_peak(
                        start_index_window, end_index_window
                    ),
                    4,
                ),
                "value": self.mv_value,
            }
        }


class TmsPatient:
    subject_name: str
    path: str

    measurement_data: dict[str, dict[str, TmsMeasurement]]
    import_report: list
    preferences: dict

    start_time_si1mv: float = 0.10
    end_time_si1mv: float = 0.13

    start_time_recr: float = 0.10
    end_time_recr: float = 0.13

    start_time_ici: float = 0.10
    end_time_ici: float = 0.13

    start_time_lici: float = 0.26
    end_time_lici: float = 0.30

    def __init__(self, subject_name: str, path: str) -> None:
        self.path = path
        self.subject_name = subject_name
        self.init_data_struct()
        self.load_patient_files()

    def init_data_struct(self):
        self.import_report = []
        self.measurement_data = {}
        for session in ["ba", "pm", "ac", "lt"]:
            self.measurement_data[session] = {}

    def parse_mat_file(self, file):
        valid_file = True
        file_with_no_ending = file.replace(".mat", "")
        name_components = file_with_no_ending.split("_")

        name_file = name_components[0]
        type_file = name_components[1]
        tms_file = name_components[2].lower()

        if name_file != self.subject_name:
            valid_file = False
            self.import_report.append(f"{datetime.now()}-ERROR:::: Wrong Patient Name")

        type = None
        if type_file == "BA":
            type = MeasurementType.BA
        elif type_file == "PM":
            type = MeasurementType.PM
        elif type_file == "AC":
            type = MeasurementType.AC
        elif type_file == "LT":
            type = MeasurementType.LT
        else:
            valid_file = False
            self.import_report.append(f"{datetime.now()}-ERROR:::: Wrong Type")

        if tms_file == "ici" and valid_file:
            self.measurement_data[type.name.lower()][tms_file] = Ici(
                f"{self.path}/{self.subject_name}/{file}", type
            )
            self.import_report.append(
                f"{datetime.now()}-INFO:::: {file} loaded successfully!"
            )
        elif tms_file == "lici" and valid_file:
            self.measurement_data[type.name.lower()][tms_file] = Lici(
                f"{self.path}/{self.subject_name}/{file}", type
            )
            self.import_report.append(
                f"{datetime.now()}-INFO:::: {file} loaded successfully!"
            )
        elif tms_file == "recr" and valid_file:
            self.measurement_data[type.name.lower()][tms_file] = Recr(
                f"{self.path}/{self.subject_name}/{file}", type
            )
            self.import_report.append(
                f"{datetime.now()}-INFO:::: {file} loaded successfully!"
            )
        elif tms_file == "si1mv" and valid_file:
            if len(name_components) > 3:
                try:
                    mv_value = int(name_components[3])
                    self.measurement_data[type.name.lower()][tms_file] = Si1mv(
                        f"{self.path}/{self.subject_name}/{file}",
                        type,
                        mv_value,
                    )
                    self.import_report.append(
                        f"{datetime.now()}-INFO:::: {file} loaded successfully!"
                    )
                except:
                    self.import_report.append(
                        f"{datetime.now()}-ERROR:::: {file} mV value could not be converted!"
                    )

            else:
                self.import_report.append(
                    f"{datetime.now()}-ERROR:::: {file} mV value could not be extracted!"
                )

        else:
            self.import_report.append(
                f"{datetime.now()}-ERROR:::: {file} could not be loaded!"
            )

    def load_preferences(self):
        preferences_filename = f"{self.path}/{self.subject_name}/.rejected.tms"
        if not os.path.isfile(preferences_filename):
            self.save_preferences()

        self.preferences = {}
        with open(preferences_filename) as pref:
            self.preferences = json.load(pref)

        for session in self.preferences:
            for type in self.preferences[session]:
                for index, rejected in enumerate(self.preferences[session][type]):
                    self.measurement_data[session][type].frames[
                        index
                    ].rejected = rejected

    def load_overwrites(self):
        overwrites_filename = f"{self.path}/{self.subject_name}/.overwrites.tms"
        if not os.path.isfile(overwrites_filename):
            self.save_overwrites()

        self.regression_overwrites = {}
        with open(overwrites_filename) as overwrites:
            self.regression_overwrites = json.load(overwrites)

        for session in self.regression_overwrites:
            if self.regression_overwrites[session] != "Default":
                if "recr" in self.measurement_data[session].keys():
                    for model in RegressionModels:
                        if model.name == self.regression_overwrites[session]:
                            self.measurement_data[session][
                                "recr"
                            ].regression_overwrite = model

    def save_preferences(self):
        self.preferences = {}
        for session in self.measurement_data:
            self.preferences[session] = {}
            for type in self.measurement_data[session]:
                self.preferences[session][type] = []
                for frame in self.measurement_data[session][type].frames:
                    self.preferences[session][type].append(frame.rejected)

        preferences_filename = f"{self.path}/{self.subject_name}/.rejected.tms"
        with open(preferences_filename, "w") as pref:
            json.dump(self.preferences, pref)

    def save_overwrites(self):
        self.regression_overwrites = {}
        for session in self.measurement_data:
            if "recr" in self.measurement_data[session].keys():
                overwrite = "Default"
                if (
                    self.measurement_data[session]["recr"].regression_overwrite
                    is not None
                ):
                    overwrite = self.measurement_data[session][
                        "recr"
                    ].regression_overwrite.name
                self.regression_overwrites[session] = overwrite

        overwrites_filename = f"{self.path}/{self.subject_name}/.overwrites.tms"
        with open(overwrites_filename, "w") as overwrites:
            json.dump(self.regression_overwrites, overwrites)

    def load_patient_files(self):
        self.import_report.append(
            f"{datetime.now()}-INFO:::: Importing Patient {self.subject_name}"
        )
        for file in os.listdir(f"{self.path}/{self.subject_name}"):
            if file.endswith(".mat"):
                self.parse_mat_file(file)

        self.load_preferences()
        self.load_overwrites()

    def export_data(self) -> dict:
        export: dict = {}

        for session in ["ba", "pm", "ac", "lt"]:
            if len(self.measurement_data.get(session)) != 0:
                export[session] = {}
                if self.measurement_data[session].get("si1mv") is not None:
                    export[session].update(
                        self.measurement_data[session]["si1mv"].export_data(
                            self.start_time_si1mv, self.end_time_si1mv
                        )
                    )

                if self.measurement_data[session].get("recr") is not None:
                    export[session].update(
                        self.measurement_data[session]["recr"].export_data(
                            self.start_time_recr, self.end_time_recr
                        )
                    )

                if self.measurement_data[session].get("ici") is not None:
                    export[session].update(
                        self.measurement_data[session]["ici"].export_data(
                            self.start_time_ici, self.end_time_ici
                        )
                    )

                if self.measurement_data[session].get("lici") is not None:
                    export[session].update(
                        self.measurement_data[session]["lici"].export_data(
                            self.start_time_lici, self.end_time_lici
                        )
                    )

        return {self.subject_name: export}

    def filtered_measurements(
        self,
        session_types: list[str],
        tms_types: list[str],
        only_inspection_needed: bool = False,
        show_rejected: bool = True,
    ) -> list[TmsFrame]:
        """"""

        filtered_frames = []
        for session_type in session_types:
            for tms_type in tms_types:
                for frame in self.measurement_data[session_type][tms_type].frames:
                    if only_inspection_needed:
                        if frame.inspection_needed:
                            filtered_frames.append(frame)
                        else:
                            if show_rejected:
                                filtered_frames.append(frame)
                            else:
                                if not frame.rejected:
                                    filtered_frames.append(frame)

        return filtered_frames

    def get_count_inspection_needed(self, key: str):
        count = 0
        if self.measurement_data.get(key) is not None:
            for mes_type in self.measurement_data[key]:
                count += self.measurement_data[key][
                    mes_type
                ].get_count_inspection_needed()
            return count
        return -1

    def get_count_rejected(self, key: str):
        count = 0
        if self.measurement_data.get(key) is not None:
            for mes_type in self.measurement_data[key]:
                count += self.measurement_data[key][mes_type].get_count_rejected()
            return count
        return -1

    def plot(self, session: str, type: str, fig: Figure):
        current_mes: TmsMeasurement = self.measurement_data[session][type]
        if isinstance(current_mes, Si1mv):
            current_mes.plot_external(fig, self.start_time_si1mv, self.end_time_si1mv)
        elif isinstance(current_mes, Recr):
            current_mes.plot_external(fig, self.start_time_recr, self.end_time_recr)
        elif isinstance(current_mes, Ici):
            current_mes.plot_external(fig, self.start_time_ici, self.end_time_ici)
        elif isinstance(current_mes, Lici):
            current_mes.plot_external(fig, self.start_time_lici, self.end_time_lici)
